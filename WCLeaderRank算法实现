#第一部分使用WLR算法计算节目节点得分排名
setwd('d:/rdata/rcode')
library(Matrix)
data<-read.csv('tv6.csv',head=TRUE)
names(data) <- c('from', 'to','value')
fid <- unique(data$from)
tid <- unique(data$to)
vid <- (data$value)
#确定节点集并排序
uid <- sort(union(fid, tid)) #获取不同的节点集合并排序(保证了上三角矩阵)
#添加一个背景节点，将节点集的长度扩充至mlen
mlen <- length(uid)+1
#建立一个mlen*mlen的邻接矩阵
A <- Matrix(data=0, nrow=mlen, ncol=mlen)
fidx <- match(data[[1]], uid, nomatch=0)
tidx <- match(data[[2]], uid, nomatch=0)
idx <- matrix(c(fidx, tidx), ncol=2)#生成mlen行2列的矩阵
vidx <- matrix(c(fidx, tidx,vid), ncol=3)#生成mlen行3列的矩阵
A[idx] <- vid
A[mlen,]<- 1
A[,mlen] <- 1
A
uid
write.csv(uid,'uid.csv',row.names=FALSE)

#以下是leaderrank算法
N <- nrow(A) - 1
#根据邻接矩阵A生成概率转移矩阵M
K <- Diagonal(x=1/rowSums(A))
M <- t(K %*% A)
M
#给N+1个节点赋予初值
R0 <- matrix(1, nrow=N+1, ncol=1)
R0[N+1,1] <- 0
#给定收敛停止精度和最大迭代次数
EPS <- 0.0001
MAXITER <- 50 
#执行循环得到收敛的最终的R值
for(i in 1:MAXITER){
  R <- M %*% R0
  e <- sum(abs(R-R0))
  cat(paste('iteration', i, 'error', e), '\n')
  if(e < EPS) break
  R0 <- R
  }
#把第N+1个节点的得分按入度与边的比值给其他N个节点并输出得分向量R
library(igraph)
g<-graph.data.frame(vidx)
#degree_in=degree(g)
degree_in=degree(g,mode='in')
#degree_in=degree(g,mode='out')
V=341
sg <- R0[N+1,1]*(degree_in/V)
R <- as.vector(R)
length(R) <- N
Rd=R+sg
Rd

#标准化最后的leaderrank得分，使其得分区间为[0,1]
MIN_NUM <- 0.0000001
if(min(Rd) == 0) Rd <- Rd+MIN_NUM
R1 <- log(Rd)
min_r <- min(R1)
max_r <- max(R1)
lt<-0
ht<-1
R2 <- (ht-lt)*(R1 - min_r)/(max_r-min_r) + lt
R2

#输出得分排名
ix <- sort(Rd, index.return=TRUE, decreasing=TRUE)$ix
out <- paste(seq(1, length(uid)), uid[ix], sprintf('%.4f', Rd[ix]), sep=',')
out
write.csv(out,'tv6-wcleaderrank2.csv',row.names=FALSE)
